-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module MonisApp.Subscription exposing (..)

import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.Operation exposing (RootMutation, RootQuery, RootSubscription)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode exposing (Decoder)
import MonisApp.Enum.Accounts_select_column
import MonisApp.Enum.Categories_select_column
import MonisApp.Enum.Transactions_select_column
import MonisApp.Enum.Users_select_column
import MonisApp.InputObject
import MonisApp.Interface
import MonisApp.Object
import MonisApp.Scalar
import MonisApp.ScalarCodecs
import MonisApp.Union


type alias AccountsOptionalArguments =
    { distinct_on : OptionalArgument (List MonisApp.Enum.Accounts_select_column.Accounts_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List MonisApp.InputObject.Accounts_order_by)
    , where_ : OptionalArgument MonisApp.InputObject.Accounts_bool_exp
    }


{-| fetch data from the table: "accounts"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
accounts :
    (AccountsOptionalArguments -> AccountsOptionalArguments)
    -> SelectionSet decodesTo MonisApp.Object.Accounts
    -> SelectionSet (List decodesTo) RootSubscription
accounts fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum MonisApp.Enum.Accounts_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (MonisApp.InputObject.encodeAccounts_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ MonisApp.InputObject.encodeAccounts_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "accounts" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias AccountsAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List MonisApp.Enum.Accounts_select_column.Accounts_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List MonisApp.InputObject.Accounts_order_by)
    , where_ : OptionalArgument MonisApp.InputObject.Accounts_bool_exp
    }


{-| fetch aggregated fields from the table: "accounts"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
accounts_aggregate :
    (AccountsAggregateOptionalArguments -> AccountsAggregateOptionalArguments)
    -> SelectionSet decodesTo MonisApp.Object.Accounts_aggregate
    -> SelectionSet decodesTo RootSubscription
accounts_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum MonisApp.Enum.Accounts_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (MonisApp.InputObject.encodeAccounts_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ MonisApp.InputObject.encodeAccounts_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "accounts_aggregate" optionalArgs____ object____ Basics.identity


type alias AccountsByPkRequiredArguments =
    { id : MonisApp.ScalarCodecs.Uuid }


{-| fetch data from the table: "accounts" using primary key columns
-}
accounts_by_pk :
    AccountsByPkRequiredArguments
    -> SelectionSet decodesTo MonisApp.Object.Accounts
    -> SelectionSet (Maybe decodesTo) RootSubscription
accounts_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "accounts_by_pk" [ Argument.required "id" requiredArgs____.id (MonisApp.ScalarCodecs.codecs |> MonisApp.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias CategoriesOptionalArguments =
    { distinct_on : OptionalArgument (List MonisApp.Enum.Categories_select_column.Categories_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List MonisApp.InputObject.Categories_order_by)
    , where_ : OptionalArgument MonisApp.InputObject.Categories_bool_exp
    }


{-| fetch data from the table: "categories"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
categories :
    (CategoriesOptionalArguments -> CategoriesOptionalArguments)
    -> SelectionSet decodesTo MonisApp.Object.Categories
    -> SelectionSet (List decodesTo) RootSubscription
categories fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum MonisApp.Enum.Categories_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (MonisApp.InputObject.encodeCategories_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ MonisApp.InputObject.encodeCategories_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "categories" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias CategoriesAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List MonisApp.Enum.Categories_select_column.Categories_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List MonisApp.InputObject.Categories_order_by)
    , where_ : OptionalArgument MonisApp.InputObject.Categories_bool_exp
    }


{-| fetch aggregated fields from the table: "categories"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
categories_aggregate :
    (CategoriesAggregateOptionalArguments -> CategoriesAggregateOptionalArguments)
    -> SelectionSet decodesTo MonisApp.Object.Categories_aggregate
    -> SelectionSet decodesTo RootSubscription
categories_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum MonisApp.Enum.Categories_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (MonisApp.InputObject.encodeCategories_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ MonisApp.InputObject.encodeCategories_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "categories_aggregate" optionalArgs____ object____ Basics.identity


type alias CategoriesByPkRequiredArguments =
    { id : MonisApp.ScalarCodecs.Uuid }


{-| fetch data from the table: "categories" using primary key columns
-}
categories_by_pk :
    CategoriesByPkRequiredArguments
    -> SelectionSet decodesTo MonisApp.Object.Categories
    -> SelectionSet (Maybe decodesTo) RootSubscription
categories_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "categories_by_pk" [ Argument.required "id" requiredArgs____.id (MonisApp.ScalarCodecs.codecs |> MonisApp.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias TransactionsOptionalArguments =
    { distinct_on : OptionalArgument (List MonisApp.Enum.Transactions_select_column.Transactions_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List MonisApp.InputObject.Transactions_order_by)
    , where_ : OptionalArgument MonisApp.InputObject.Transactions_bool_exp
    }


{-| fetch data from the table: "transactions"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
transactions :
    (TransactionsOptionalArguments -> TransactionsOptionalArguments)
    -> SelectionSet decodesTo MonisApp.Object.Transactions
    -> SelectionSet (List decodesTo) RootSubscription
transactions fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum MonisApp.Enum.Transactions_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (MonisApp.InputObject.encodeTransactions_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ MonisApp.InputObject.encodeTransactions_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "transactions" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias TransactionsAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List MonisApp.Enum.Transactions_select_column.Transactions_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List MonisApp.InputObject.Transactions_order_by)
    , where_ : OptionalArgument MonisApp.InputObject.Transactions_bool_exp
    }


{-| fetch aggregated fields from the table: "transactions"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
transactions_aggregate :
    (TransactionsAggregateOptionalArguments -> TransactionsAggregateOptionalArguments)
    -> SelectionSet decodesTo MonisApp.Object.Transactions_aggregate
    -> SelectionSet decodesTo RootSubscription
transactions_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum MonisApp.Enum.Transactions_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (MonisApp.InputObject.encodeTransactions_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ MonisApp.InputObject.encodeTransactions_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "transactions_aggregate" optionalArgs____ object____ Basics.identity


type alias TransactionsByPkRequiredArguments =
    { id : MonisApp.ScalarCodecs.Uuid }


{-| fetch data from the table: "transactions" using primary key columns
-}
transactions_by_pk :
    TransactionsByPkRequiredArguments
    -> SelectionSet decodesTo MonisApp.Object.Transactions
    -> SelectionSet (Maybe decodesTo) RootSubscription
transactions_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "transactions_by_pk" [ Argument.required "id" requiredArgs____.id (MonisApp.ScalarCodecs.codecs |> MonisApp.Scalar.unwrapEncoder .codecUuid) ] object____ (Basics.identity >> Decode.nullable)


type alias UsersOptionalArguments =
    { distinct_on : OptionalArgument (List MonisApp.Enum.Users_select_column.Users_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List MonisApp.InputObject.Users_order_by)
    , where_ : OptionalArgument MonisApp.InputObject.Users_bool_exp
    }


{-| fetch data from the table: "users"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
users :
    (UsersOptionalArguments -> UsersOptionalArguments)
    -> SelectionSet decodesTo MonisApp.Object.Users
    -> SelectionSet (List decodesTo) RootSubscription
users fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum MonisApp.Enum.Users_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (MonisApp.InputObject.encodeUsers_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ MonisApp.InputObject.encodeUsers_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "users" optionalArgs____ object____ (Basics.identity >> Decode.list)


type alias UsersAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List MonisApp.Enum.Users_select_column.Users_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List MonisApp.InputObject.Users_order_by)
    , where_ : OptionalArgument MonisApp.InputObject.Users_bool_exp
    }


{-| fetch aggregated fields from the table: "users"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
users_aggregate :
    (UsersAggregateOptionalArguments -> UsersAggregateOptionalArguments)
    -> SelectionSet decodesTo MonisApp.Object.Users_aggregate
    -> SelectionSet decodesTo RootSubscription
users_aggregate fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs____ =
            [ Argument.optional "distinct_on" filledInOptionals____.distinct_on (Encode.enum MonisApp.Enum.Users_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals____.limit Encode.int, Argument.optional "offset" filledInOptionals____.offset Encode.int, Argument.optional "order_by" filledInOptionals____.order_by (MonisApp.InputObject.encodeUsers_order_by |> Encode.list), Argument.optional "where" filledInOptionals____.where_ MonisApp.InputObject.encodeUsers_bool_exp ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "users_aggregate" optionalArgs____ object____ Basics.identity


type alias UsersByPkRequiredArguments =
    { id : String }


{-| fetch data from the table: "users" using primary key columns
-}
users_by_pk :
    UsersByPkRequiredArguments
    -> SelectionSet decodesTo MonisApp.Object.Users
    -> SelectionSet (Maybe decodesTo) RootSubscription
users_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "users_by_pk" [ Argument.required "id" requiredArgs____.id Encode.string ] object____ (Basics.identity >> Decode.nullable)
